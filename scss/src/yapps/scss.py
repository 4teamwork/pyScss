# python yapps2.py grammar.g grammar.py

################################################################################
## Grammar compiled using Yapps:

# Begin -- grammar generated by Yapps
import re
try:
    from yapps.runtime import Scanner, Parser, Context, wrap_error_reporter
except ImportError:
    from runtime import Scanner, Parser, Context, wrap_error_reporter


class SassExpressionScanner(Scanner):
    patterns = None
    _patterns = [
        ('":"', ':'),
        ('[ \r\t\n]+', '[ \r\t\n]+'),
        ('COMMA', ','),
        ('LPAR', '\\(|\\['),
        ('RPAR', '\\)|\\]'),
        ('END', '$'),
        ('MUL', '[*]'),
        ('DIV', '/'),
        ('ADD', '[+]'),
        ('SUB', '-\\s'),
        ('SIGN', '-(?![a-zA-Z_])'),
        ('AND', '(?<![-\\w])and(?![-\\w])'),
        ('OR', '(?<![-\\w])or(?![-\\w])'),
        ('NOT', '(?<![-\\w])not(?![-\\w])'),
        ('NE', '!='),
        ('INV', '!'),
        ('EQ', '=='),
        ('LE', '<='),
        ('GE', '>='),
        ('LT', '<'),
        ('GT', '>'),
        ('STR', "'[^']*'"),
        ('QSTR', '"[^"]*"'),
        ('UNITS', '(?<!\\s)(?:[a-zA-Z]+|%)(?![-\\w])'),
        ('NUM', '(?:\\d+(?:\\.\\d*)?|\\.\\d+)'),
        ('COLOR', '#(?:[a-fA-F0-9]{6}|[a-fA-F0-9]{3})(?![a-fA-F0-9])'),
        ('VAR', '\\$[-a-zA-Z0-9_]+'),
        ('NAME', '\\$?[-a-zA-Z0-9_]+'),
        ('FNCT', '[-a-zA-Z_][-a-zA-Z0-9_]*(?=\\()'),
        ('ID', '!?[-a-zA-Z_][-a-zA-Z0-9_]*'),
    ]

    def __init__(self, str, *args, **kw):
        if hasattr(self, 'setup_patterns'):
            self.setup_patterns(self._patterns)
        elif self.patterns is None:
            self.__class__.patterns = []
            for t, p in self._patterns:
                self.patterns.append((t, re.compile(p)))
        super(SassExpressionScanner, self).__init__(None, {'[ \r\t\n]+': None, }, str, *args, **kw)


class SassExpression(Parser):
    Context = Context

    def goal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'goal', [])
        expr_lst = self.expr_lst(_context)
        END = self._scan('END', context=_context)
        return expr_lst

    def expr_lst(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'expr_lst', [])
        expr_item = self.expr_item(_context)
        v = [expr_item]
        while self._peek(self._END_COMMA_RPAR, context=_context) == self._COMMA:
            COMMA = self._scan('COMMA', context=_context)
            expr_item = (None, Literal(Undefined()))
            if self._peek(self._LPAR_END_NAME_COLOR_QSTR_SIGN_, context=_context) not in self._END_COMMA_RPAR:
                expr_item = self.expr_item(_context)
            v.append(expr_item)
        return ListLiteral(v) if len(v) > 1 else v[0][1]

    def expr_item(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'expr_item', [])
        NAME = None
        if self._peek(self._LPAR_NAME_COLOR_QSTR_SIGN_VAR_, context=_context) == self._NAME:
            NAME = self._scan('NAME', context=_context)
            self._scan('":"', context=_context)
        expr_slst = self.expr_slst(_context)
        return (NAME, expr_slst)

    def expr_slst(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'expr_slst', [])
        or_expr = self.or_expr(_context)
        v = [(None, or_expr)]
        while self._peek(self._LPAR_END_COLOR_QSTR_SIGN_VAR__, context=_context) not in self._END_COMMA_RPAR:
            or_expr = self.or_expr(_context)
            v.append((None, or_expr))
        return ListLiteral(v, comma=False) if len(v) > 1 else v[0][1]

    def or_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'or_expr', [])
        and_expr = self.and_expr(_context)
        v = and_expr
        while self._peek(self._LPAR_RPAR_END_COLOR_QSTR_ID_V_, context=_context) == self._OR:
            OR = self._scan('OR', context=_context)
            and_expr = self.and_expr(_context)
            v = AnyOp(v, and_expr)
        return v

    def and_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'and_expr', [])
        not_expr = self.not_expr(_context)
        v = not_expr
        while self._peek(self._AND_LPAR_END_COLOR_QSTR_SIGN__, context=_context) == self._AND:
            AND = self._scan('AND', context=_context)
            not_expr = self.not_expr(_context)
            v = AllOp(v, not_expr)
        return v

    def not_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'not_expr', [])
        _token = self._peek(self._LPAR_COLOR_QSTR_SIGN_VAR_ADD__, context=_context)
        if _token != self._NOT:
            comparison = self.comparison(_context)
            return comparison
        else:  # == self._NOT
            NOT = self._scan('NOT', context=_context)
            not_expr = self.not_expr(_context)
            return NotOp(not_expr)

    def comparison(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'comparison', [])
        a_expr = self.a_expr(_context)
        v = a_expr
        while self._peek(self._LPAR_QSTR_RPAR_LE_COLOR_NE_LT_, context=_context) in self._GT_GE_NE_LT_LE_EQ:
            _token = self._peek(self._GT_GE_NE_LT_LE_EQ, context=_context)
            if _token == self._LT:
                LT = self._scan('LT', context=_context)
                a_expr = self.a_expr(_context)
                v = BinaryOp(operator.lt, v, a_expr)
            elif _token == self._GT:
                GT = self._scan('GT', context=_context)
                a_expr = self.a_expr(_context)
                v = BinaryOp(operator.gt, v, a_expr)
            elif _token == self._LE:
                LE = self._scan('LE', context=_context)
                a_expr = self.a_expr(_context)
                v = BinaryOp(operator.le, v, a_expr)
            elif _token == self._GE:
                GE = self._scan('GE', context=_context)
                a_expr = self.a_expr(_context)
                v = BinaryOp(operator.ge, v, a_expr)
            elif _token == self._EQ:
                EQ = self._scan('EQ', context=_context)
                a_expr = self.a_expr(_context)
                v = BinaryOp(operator.eq, v, a_expr)
            else:  # == self._NE
                NE = self._scan('NE', context=_context)
                a_expr = self.a_expr(_context)
                v = BinaryOp(operator.ne, v, a_expr)
        return v

    def a_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'a_expr', [])
        m_expr = self.m_expr(_context)
        v = m_expr
        while self._peek(self._LPAR_SUB_QSTR_RPAR_LE_COLOR_N_, context=_context) in self._ADD_SUB:
            _token = self._peek(self._ADD_SUB, context=_context)
            if _token == self._ADD:
                ADD = self._scan('ADD', context=_context)
                m_expr = self.m_expr(_context)
                v = BinaryOp(operator.add, v, m_expr)
            else:  # == self._SUB
                SUB = self._scan('SUB', context=_context)
                m_expr = self.m_expr(_context)
                v = BinaryOp(operator.sub, v, m_expr)
        return v

    def m_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'm_expr', [])
        u_expr = self.u_expr(_context)
        v = u_expr
        while self._peek(self._LPAR_SUB_QSTR_RPAR_MUL_DIV_LE_, context=_context) in self._MUL_DIV:
            _token = self._peek(self._MUL_DIV, context=_context)
            if _token == self._MUL:
                MUL = self._scan('MUL', context=_context)
                u_expr = self.u_expr(_context)
                v = BinaryOp(operator.mul, v, u_expr)
            else:  # == self._DIV
                DIV = self._scan('DIV', context=_context)
                u_expr = self.u_expr(_context)
                v = BinaryOp(operator.truediv, v, u_expr)
        return v

    def u_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'u_expr', [])
        _token = self._peek(self._LPAR_COLOR_QSTR_SIGN_ADD_NUM__, context=_context)
        if _token == self._SIGN:
            SIGN = self._scan('SIGN', context=_context)
            u_expr = self.u_expr(_context)
            return UnaryOp(operator.neg, u_expr)
        elif _token == self._ADD:
            ADD = self._scan('ADD', context=_context)
            u_expr = self.u_expr(_context)
            return UnaryOp(operator.pos, u_expr)
        else:  # in self._LPAR_COLOR_QSTR_NUM_FNCT_STR__
            atom = self.atom(_context)
            return atom

    def atom(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'atom', [])
        _token = self._peek(self._LPAR_COLOR_QSTR_NUM_FNCT_STR__, context=_context)
        if _token == self._ID:
            ID = self._scan('ID', context=_context)
            return Literal(parse_bareword(ID))
        elif _token == self._LPAR:
            LPAR = self._scan('LPAR', context=_context)
            expr_lst = ListLiteral()
            if self._peek(self._LPAR_END_NAME_COLOR_QSTR_SIGN__, context=_context) not in self._END_RPAR:
                expr_lst = self.expr_lst(_context)
            RPAR = self._scan('RPAR', context=_context)
            return Parentheses(expr_lst)
        elif _token == self._FNCT:
            FNCT = self._scan('FNCT', context=_context)
            LPAR = self._scan('LPAR', context=_context)
            expr_lst = ListLiteral()
            if self._peek(self._LPAR_END_NAME_COLOR_QSTR_SIGN__, context=_context) not in self._END_RPAR:
                expr_lst = self.expr_lst(_context)
            RPAR = self._scan('RPAR', context=_context)
            return CallOp(FNCT, expr_lst)
        elif _token == self._NUM:
            NUM = self._scan('NUM', context=_context)
            UNITS = None
            if self._peek(self._LPAR_SUB_QSTR_RPAR_VAR_MUL_DI_, context=_context) == self._UNITS:
                UNITS = self._scan('UNITS', context=_context)
            return Literal(NumberValue(float(NUM), unit=UNITS))
        elif _token == self._STR:
            STR = self._scan('STR', context=_context)
            return Literal(String(STR[1:-1], quotes="'"))
        elif _token == self._QSTR:
            QSTR = self._scan('QSTR', context=_context)
            return Literal(String(QSTR[1:-1], quotes='"'))
        elif _token == self._COLOR:
            COLOR = self._scan('COLOR', context=_context)
            return Literal(ColorValue(ParserValue(COLOR)))
        else:  # == self._VAR
            VAR = self._scan('VAR', context=_context)
            return Variable(VAR)

    _COLOR = 'COLOR'
    _GE = 'GE'
    _FNCT = 'FNCT'
    _AND = 'AND'
    _ADD_SUB = set(['ADD', 'SUB'])
    _DIV = 'DIV'
    _COMMA = 'COMMA'
    _LPAR_COLOR_QSTR_NUM_FNCT_STR__ = set(['LPAR', 'COLOR', 'QSTR', 'NUM', 'FNCT', 'STR', 'VAR', 'ID'])
    _GT = 'GT'
    _EQ = 'EQ'
    _GT_GE_NE_LT_LE_EQ = set(['GT', 'GE', 'NE', 'LT', 'LE', 'EQ'])
    _END_COMMA_RPAR = set(['END', 'COMMA', 'RPAR'])
    _LPAR_NAME_COLOR_QSTR_SIGN_VAR_ = set(['LPAR', 'NAME', 'COLOR', 'QSTR', 'SIGN', 'VAR', 'ADD', 'NUM', 'FNCT', 'STR', 'NOT', 'ID'])
    _LT = 'LT'
    _LPAR_SUB_QSTR_RPAR_LE_COLOR_N_ = set(['LPAR', 'SUB', 'QSTR', 'RPAR', 'LE', 'COLOR', 'NE', 'LT', 'NUM', 'COMMA', 'GT', 'END', 'SIGN', 'GE', 'FNCT', 'STR', 'VAR', 'EQ', 'ID', 'AND', 'ADD', 'NOT', 'OR'])
    _MUL = 'MUL'
    _STR = 'STR'
    _NAME = 'NAME'
    _LPAR_END_NAME_COLOR_QSTR_SIGN__ = set(['LPAR', 'END', 'NAME', 'COLOR', 'QSTR', 'SIGN', 'VAR', 'ADD', 'NUM', 'FNCT', 'STR', 'NOT', 'RPAR', 'ID'])
    _LE = 'LE'
    _VAR = 'VAR'
    _NE = 'NE'
    _SIGN = 'SIGN'
    _QSTR = 'QSTR'
    _LPAR_SUB_QSTR_RPAR_MUL_DIV_LE_ = set(['LPAR', 'SUB', 'QSTR', 'RPAR', 'MUL', 'DIV', 'LE', 'COLOR', 'NE', 'LT', 'NUM', 'COMMA', 'GT', 'END', 'SIGN', 'GE', 'FNCT', 'STR', 'VAR', 'EQ', 'ID', 'AND', 'ADD', 'NOT', 'OR'])
    _UNITS = 'UNITS'
    _LPAR_RPAR_END_COLOR_QSTR_ID_V_ = set(['LPAR', 'RPAR', 'END', 'COLOR', 'QSTR', 'ID', 'VAR', 'ADD', 'NUM', 'COMMA', 'FNCT', 'STR', 'NOT', 'SIGN', 'OR'])
    _NUM = 'NUM'
    _LPAR_QSTR_RPAR_LE_COLOR_NE_LT_ = set(['LPAR', 'QSTR', 'RPAR', 'LE', 'COLOR', 'NE', 'LT', 'NUM', 'COMMA', 'GT', 'END', 'SIGN', 'ADD', 'FNCT', 'STR', 'VAR', 'EQ', 'ID', 'AND', 'GE', 'NOT', 'OR'])
    _END_RPAR = set(['END', 'RPAR'])
    _LPAR_SUB_QSTR_RPAR_VAR_MUL_DI_ = set(['LPAR', 'SUB', 'QSTR', 'RPAR', 'VAR', 'MUL', 'DIV', 'LE', 'COLOR', 'NE', 'LT', 'NUM', 'COMMA', 'GT', 'END', 'SIGN', 'GE', 'FNCT', 'STR', 'UNITS', 'EQ', 'ID', 'AND', 'ADD', 'NOT', 'OR'])
    _AND_LPAR_END_COLOR_QSTR_SIGN__ = set(['AND', 'LPAR', 'END', 'COLOR', 'QSTR', 'SIGN', 'VAR', 'ADD', 'NUM', 'COMMA', 'FNCT', 'STR', 'NOT', 'ID', 'RPAR', 'OR'])
    _LPAR_END_NAME_COLOR_QSTR_SIGN_ = set(['LPAR', 'END', 'NAME', 'COLOR', 'QSTR', 'SIGN', 'VAR', 'ADD', 'NUM', 'COMMA', 'FNCT', 'STR', 'NOT', 'RPAR', 'ID'])
    _LPAR_COLOR_QSTR_SIGN_VAR_ADD__ = set(['LPAR', 'COLOR', 'QSTR', 'SIGN', 'VAR', 'ADD', 'NUM', 'FNCT', 'STR', 'NOT', 'ID'])
    _MUL_DIV = set(['MUL', 'DIV'])
    _ID = 'ID'
    _OR = 'OR'
    _LPAR_END_COLOR_QSTR_SIGN_VAR__ = set(['LPAR', 'END', 'COLOR', 'QSTR', 'SIGN', 'VAR', 'ADD', 'NUM', 'COMMA', 'FNCT', 'STR', 'NOT', 'RPAR', 'ID'])
    _LPAR = 'LPAR'
    _ADD = 'ADD'
    _NOT = 'NOT'
    _LPAR_COLOR_QSTR_SIGN_ADD_NUM__ = set(['LPAR', 'COLOR', 'QSTR', 'SIGN', 'ADD', 'NUM', 'FNCT', 'STR', 'VAR', 'ID'])
    _SUB = 'SUB'


def parse(rule, text):
    P = SassExpression(SassExpressionScanner(text))
    return wrap_error_reporter(P, rule)

# End -- grammar generated by Yapps
### Grammar ends.
################################################################################
